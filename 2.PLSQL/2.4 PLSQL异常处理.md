## 异常处理

### 1. 异常处理-分类

　程序抛出异常时往往会包含两部分内容：**错误编码+错误信息**，有些异常还会带有错误名称。

　根据异常是否由数据库判定分为**系统异常**和**自定义异常**，**系统异常**中又根据异常是否带有错误名称**分为** **预定义异常**和**非预定义异常**。

- **预定义异常**：数据库判定，本身带有错误名称、错误编码、错误信息，能够被异常处理部分直接捕获；
- **非预定义异常**：数据库判定，本身带有错误编码和错误信息，需要给定名称后才能被异常处理部分捕获；
- **自定义异常**：业务逻辑判定，本身不存在，根据业务逻辑自行设定错误名称、错误编码和错误信息，声明后才能被异常处理部分捕获。

### 2. 异常处理-结构

```SQL
EXCEPTION
  WHEN err_name1 THEN
    except_sentence2;
    ...
    except_sentence1;
  WHEN err_name2 THEN
  WHEN OTHERS THEN
    except_sentencen;
```


#### 1. 异常处理-预定义异常

　　**预定义异常**在使用时完全不需要用户声明，由**ORACLE**自行引发自行判定。

```SQL
BEGIN 
  plsql_sentence;
  EXCEPTION
  WHEN err_name THEN
    except_sentence;
END;
```



```SQL
DECLARE
  V_ENAME VARCHAR2(10);
BEGIN
  SELECT ENAME INTO V_ENAME FROM EMP WHERE EMPNO = 1234;
/*SELECT ENAME INTO V_ENAME FROM EMP WHERE DEPTNO = 10;*/
  DBMS_OUTPUT.PUT_LINE(V_ENAME);
EXCEPTION
  WHEN NO_DATA_FOUND THEN
    DBMS_OUTPUT.PUT_LINE('这个员工不存在');
/*WHEN TOO_MANY_ROWS THEN
    DBMS_OUTPUT.PUT_LINE('数据过多');*/
END;
```



```SQL
CREATE TABLE ERR_INFO(ERR_INFO VARCHAR2(500),TS VARCHAR2(30));  --创建日志表
SELECT * FROM ERR_INFO;  --查询日志表
/
DECLARE
  V_ENAME VARCHAR2(10);
BEGIN
  SELECT ENAME INTO V_ENAME FROM EMP WHERE EMPNO = 7369;
/*SELECT ENAME INTO V_ENAME FROM EMP WHERE EMPNO = 1234;  --数据不存在*/  --出现第1次异常后，程序执行就已经停止了，后续异常不会再出现
/*SELECT ENAME INTO V_ENAME FROM EMP WHERE DEPTNO = 10;   --数据过多 */
/*EXECUTE IMMEDIATE 'DELETE TABLE EEE';                   --表不存在 */
  DBMS_OUTPUT.PUT_LINE(V_ENAME);
  INSERT INTO ERR_INFO VALUES('程序正常运行',TO_CHAR(SYSDATE,'YYYY/MM/DD HH24:MI:SS'));
EXCEPTION
  WHEN NO_DATA_FOUND THEN
    INSERT INTO ERR_INFO VALUES('数据不存在',TO_CHAR(SYSDATE,'YYYY/MM/DD HH24:MI:SS'));
    COMMIT;  --插入错误信息到日志表并提交
    RAISE;   --引发报错弹窗
  WHEN TOO_MANY_ROWS THEN
    INSERT INTO ERR_INFO VALUES('数据过多',TO_CHAR(SYSDATE,'YYYY/MM/DD HH24:MI:SS'));
    COMMIT;  --插入错误信息到日志表并提交
    RAISE;   --引发报错弹窗
  WHEN OTHERS THEN
    INSERT INTO ERR_INFO VALUES('程序异常',TO_CHAR(SYSDATE,'YYYY/MM/DD HH24:MI:SS'));
    COMMIT;  --插入错误信息到日志表并提交
    RAISE;   --引发报错弹窗
END;
/
SELECT * FROM ERR_INFO;  --查询日志表

TRUNCATE TABLE ERR_INFO;  --清空日志表
SELECT * FROM ERR_INFO;  --查询日志表
DROP TABLE ERR_INFO;  --删除日志表
```



```SQL
DECLARE
  V_ENAME VARCHAR2(10);
BEGIN
  SELECT ENAME INTO V_ENAME FROM EMP WHERE EMPNO = 7369;
/*SELECT ENAME INTO V_ENAME FROM EMP WHERE EMPNO = 1234;  --数据不存在*/
/*SELECT ENAME INTO V_ENAME FROM EMP WHERE DEPTNO = 10;   --数据过多 */
/*EXECUTE IMMEDIATE 'DELETE TABLE EEE';                   --表不存在 */
  DBMS_OUTPUT.PUT_LINE(V_ENAME);
  INSERT INTO ERR_INFO VALUES('程序正常运行',TO_CHAR(SYSDATE,'YYYY/MM/DD HH24:MI:SS'));
EXCEPTION
  WHEN OTHERS THEN
    INSERT INTO ERR_INFO VALUES('程序异常',TO_CHAR(SYSDATE,'YYYY/MM/DD HH24:MI:SS'));
    COMMIT;  --插入错误信息到日志表并提交
    RAISE;   --引发弹窗
END;
```



#### 2. 异常处理-非预定义异常

　　**非预定义异常**根本上也是属于**ORACLE**系统自带，有**错误编码**但是没有**错误名称**。

　　使用**非预定义异常**时需要先在声明部分命名一个**错误名称（EXCEPTION类型）**，再通过`PRAGMA EXCEPTION_INIT`将**错误名称**与系统自带的**错误编码**关联起来，之后就可以在异常处理中捕获该错误了。

```SQL
DECLARE
  err_name EXCEPTION;
  PRAGMA EXCEPTION_INIT(err_name,err_code);
BEGIN
  plsql_sentence;
  EXCEPTION
  WHEN err_name THEN
    except_sentence;
END;
```



```SQL
DECLARE
  V_DEPTNO  NUMBER;
  V_SAL_SUM NUMBER;
  ZHANGSAN  EXCEPTION;
  PRAGMA EXCEPTION_INIT(ZHANGSAN,-00937);
BEGIN
  SELECT DEPTNO,SUM(SAL) INTO V_DEPTNO,V_SAL_SUM FROM EMP;
EXCEPTION
  WHEN ZHANGSAN THEN
    DBMS_OUTPUT.PUT_LINE('出错啦');
END;
```



```SQL
DECLARE
  V_ENAME  VARCHAR2(10);
  ZHANGSAN EXCEPTION;
  PRAGMA EXCEPTION_INIT(ZHANGSAN,-01422);
BEGIN
  SELECT ENAME INTO V_ENAME FROM EMP WHERE DEPTNO = 90;
  DBMS_OUTPUT.PUT_LINE(V_ENAME);
  INSERT INTO ERR_INFO VALUES('程序正常运行',TO_CHAR(SYSDATE,'YYYY/MM/DD HH24:MI:SS'));
EXCEPTION
  WHEN ZHANGSAN THEN
    DBMS_OUTPUT.PUT_LINE('2');  --结果输出1  原本带有名字的错误，会以自己名字为准
  WHEN NO_DATA_FOUND THEN
    DBMS_OUTPUT.PUT_LINE('1');
END;
```



```SQL
DECLARE
  EMP_RE EXCEPTION;
  PRAGMA EXCEPTION_INIT (EMP_RE,-2292);
  V_DEPTNO DEPT.DEPTNO%TYPE := &P_DEPTNO;
BEGIN
  DELETE FROM DEPT WHERE DEPTNO=V_DEPTNO;
  EXCEPTION 
  WHEN EMP_RE THEN
  DBMS_OUTPUT.PUT_LINE('无法删除'||TO_CHAR(V_DEPTNO)||'这个部门'||',这个部门中还有员工');
END;
```



### 3. 异常处理-自定义异常

　由于**自定义异常**在数据库看来根本不算异常，因此在使用**自定义异常**时，声明部分只需要声明**错误名称**即可，不必关联**错误编码**；

　在执行部分中常常搭配条件语句，当符合（或不符合）某种条件时引发该异常，而引发异常所使用的关键词是**RAISE**。

　**RAISE**常常用来引发错误，具体的用法分为以下两种：

- `RAISE err_name` 转到**异常处理部分**；
- `RAISE_APPLICATION_ERROR(err_code,err_mess)`，引发**报错弹窗**。
  - `err_code`：**自定义错误编号**，限制在**-20001**到**-20999**之间
  - `err_mess`：**自定义错误信息**，字符型内容
  - PS：该自定义异常可以被关联错误名称



```SQL
DECLARE
  err_name EXCEPTION;
BEGIN
  IF <condition expressionl> THEN
    RAISE err_name;
  END IF;
  plsql_sentence 
  EXCEPTION
    WHEN err_name THEN
    except_sentence
END;
```



```SQL
DECLARE
  EMP_RE EXCEPTION;
BEGIN
  UPDATE EMP SET JOB = '&P_JOB' WHERE EMPNO = &P_EMPNO;
  IF SQL%NOTFOUND THEN
    RAISE EMP_RE;
  END IF;
  COMMIT;
EXCEPTION
  WHEN EMP_RE THEN
    DBMS_OUTPUT.PUT_LINE('该员工不存在，无效员工号');
END;
```



```SQL
BEGIN
  DELETE FROM EMP WHERE ENAME = '&P_ENAME';
  IF SQL%NOTFOUND THEN
    RAISE_APPLICATION_ERROR(-20174, '没有这个员工');
  END IF;
END;
```



　--SMITH是元老 不能走

```SQL
DECLARE
  V_ENAME VARCHAR2(10) := '&指定员工姓名';
  SMITH   EXCEPTION;
BEGIN
  IF V_ENAME = 'SMITH' THEN
  /*RAISE SMITH;*/  --ORA-06510: PL/SQL: 用户定义的异常错误未得到处理
    RAISE_APPLICATION_ERROR(-20001,'SMITH是元老不能走');  --引发报错说明
  ELSE
    DELETE FROM EMP WHERE ENAME = V_ENAME;
    COMMIT;
    DBMS_OUTPUT.PUT_LINE(V_ENAME || '己离职');
  END IF;
END;
```



```SQL
DECLARE
  V_ENAME VARCHAR2(10) := '&指定员工姓名';
  SMITH   EXCEPTION;
  PRAGMAN EXCEPTION_INIT(SMITH,-20001) ;
BEGIN
  IF V_ENAME = 'SMITH' THEN
  /*RAISE SMITH;*/
    RAISE_APPLICATION_ERROR(-20001,'SMITH是元老不能走'); --引发报错说明
  ELSE
    DELETE FROM EMP WHERE ENAME = V_ENAME;
    COMMIT;
    DBMS_OUTPUT.PUT_LINE(V_ENAME||'己离职');
  END IF;
  EXCEPTION 
    WHEN SMITH THEN 
      DBMS_OUTPUT.PUT_LINE('出错了');
      RAISE;
END;
```



##### 用户定义的异常

- SQLCODE      
  - 0 没有发现异常   
  - 1 用户定义的异常   
  - +100  NO_DATA_FOUND异常     
  - 负数  其他ORACLE服务器错误代码
- SQLERRM



　--捕获错误信息

```SQL
DECLARE
  V_DEPTNO  NUMBER;
  V_SAL_SUM NUMBER;
  V_ERRM    VARCHAR2(1000);
BEGIN
  SELECT DEPTNO,SUM(SAL) INTO V_DEPTNO,V_SAL_SUM FROM EMP;
EXCEPTION
  WHEN OTHERS THEN
    V_ERRM := SQLERRM;  --SYSDATE   SYSTIMESTAMP
    DBMS_OUTPUT.PUT_LINE(V_ERRM);
END;
```



```SQL
DECLARE
  V_DEPTNO  NUMBER;
  V_SAL_SUM NUMBER;
  V_ERRM    VARCHAR2(1000);
BEGIN
  SELECT DEPTNO, SUM(SAL) INTO V_DEPTNO, V_SAL_SUM FROM EMP;
EXCEPTION
  WHEN OTHERS THEN
    V_ERRM := SQLERRM;
    DBMS_OUTPUT.PUT_LINE(V_ERRM);
    INSERT INTO ERR_INFO VALUES(V_ERRM,TO_CHAR(SYSDATE,'YYYY/MM/DD HH24:MI:SS'));  --SQLERRM需要有变量来承接
END;
```



```SQL
DECLARE
  V_EMPNO      EMP.EMPNO%TYPE := &P_EMPNO;
  V_DEPTNO     DEPT.DEPTNO%TYPE := &P_DEPTNO;
  V_ERROR_CODE NUMBER;
  V_ERROR_DESC VARCHAR2(255);
BEGIN
  INSERT INTO EMP(EMPNO,ENAME,JOB,SAL,DEPTNO) VALUES(V_EMPNO,'AA','BB',800,V_DEPTNO);
  INSERT INTO LOG(USER_NAME,ERROR_DATE,ERROR_CODE,ERROR_DESC) VALUES(USER,SYSDATE,V_ERROR_CODE,V_ERROR_DESC);
EXCEPTION
  WHEN OTHERS THEN
    ROLLBACK;
    V_ERROR_CODE := SQLCODE;
    V_ERROR_DESC := SQLERRM;
    INSERT INTO LOG(USER_NAME,ERROR_DATE,ERROR_CODE,ERROR_DESC) VALUES(USER,SYSDATE,V_ERROR_CODE,V_ERROR_DESC);
    COMMIT;
END;
```



[PLSQL系统异常列表.xlsx](http://n.occc.ml:5244/NEOE/pic/PLSQL\PLSQL系统异常列表.xlsx) 

